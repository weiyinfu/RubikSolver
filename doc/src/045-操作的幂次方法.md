https://baike.baidu.com/item/%E4%B8%8A%E5%B8%9D%E4%B9%8B%E6%95%B0/10098625

# HalfSolver
二阶魔方在3种操作的情况下上帝之数是19，现在考虑它的一半操作。  
执行10步所能够形成的全部置换，把10步之内所能够得到的置换全部存储起来。  
当来一个问题的时候，等价于把这个问题对应的置换，分解为两个置换的乘积操作。  

这种方式能够避免状态数过多导致的状态爆炸问题。实际上，这种方法就是双向广度优先搜索的变形，但是实现比广度优先方法要灵活许多。     

空间复杂度较低，时间复杂度略高。  
同样，使用这种方法还可以实现把一个置换拆分成3份，这样空间复杂度会进一步降低。  


这种算法等价于：把比较少的基本操作需要很多步才能完成，转化为了比较多的基本操作需要很少的步完成。是一种用时间换空间的策略。    

获得了很多个操作之后，可以使用`A*`算法贪心搜索让尽量多的块实现复原。但是可能存在一些问题，使用`A*`计算量太大。    

搜索n层，然后将问题对应的置换分解为三个置换的乘积。如果直接硬搞，复杂度是`N*N`,N表示搜索n层之后的全部置换种数。为了降低复杂度，第一步使用启发式搜索，优先选择离目标尽量近的一种操作，然后通过O(N)复杂度判断是否可解。    

三阶魔方能够解决18步以内可以解决的东西。把三阶魔方的还原分成几个步骤：第一步，把底层还原；第二步，把中间层还原；第三步，把上层还原。只要每一步都可以在18步内解决，那么魔方就能够被还原。合理指定小目标，确保每个小目标都能够在特定步骤之内还原，这样问题就变得迎刃而解。    
这种方法几乎是万能的，把一个大目标拆解为若干个小目标，然后确保每个小目标能够实现。  

三阶魔方最简操作方式，使用6层打表搜索2步的SearchSolver，解决随机旋转5步的问题，在很多时候是不成功的。因为随机旋转5步是正向旋转5步，如果正向旋转5步，那么要想使用正向操作还原它的时候，可能需要15步才能还原它。所以可以把搜索步数改为3步，或者把打表层数改为8层。     

# start模式
一个魔方状态可以用颜色块进行表示，比如正方体魔方有6个面就用6种颜色表示，四面体魔方有4个面就用4种颜色。称这种形式为颜色模式。    
一个魔方的状态也可以用向量进行表示，把魔方展开成平面形状，然后从0开始进行依次编号。称这种表示形式为start模式。  
二阶魔方和三阶魔方都很容易实现颜色模式和start模式的转换，因为二阶魔方和三阶魔方中没有重复块，每个块都是独一无二的。把二阶魔方、三阶魔方涂上颜色与标注数字是一样的。只需要建立小块与平面展开的ID的映射关系即可。  
但是三阶四面体魔方存在很多重复的小立体，四阶六面体魔方也存在很多重复小立体，建立start模式和颜色模式的互相转换可能并不那么容易。  
start模式下的问题要比颜色模式下的问题难。只是在阶数较低的时候start模式和颜色模式有重合。  


# HalfSolver
魔方需要n步才能还原，搜索n/2步，建立table。  
给定问题的状态，对它施加table中的一个动作，得到中间状态，对中间状态直接求把它还原的置换，从table中把这个置换找出来。  
有了置换就有了operation。  
# GreedySolver
HalfSolver需要n/2步，table依旧太大。  
魔方需要n步还原，打标n/k步，建立table。  
给定问题的状态，使用贪心的方式，对每个状态建立一个评价机制，得到它的goodness。  
对于table中的每个操作，执行之并计算goodness。优先执行goodness最高的操作。  
但是这样可能会产生循环，为了避免状态不变，附加一条标准：执行操作之后不能与已经出现过的状态重复。 
这种方法得到的解法会比较长。  
# SearchSolver
为了解决GreedySolver步骤太多、答案太长的问题，提出了SearchSolver。出发点在于：魔方需要n步还原，打表n/k步，那么最多需要k层搜索就能够找到答案。   
SearchSolver是一种递归的搜索方式，对于每种状态，对它执行table中的每一种着法，然后评价goodness，将操作按照goodness进行降序排序。然后依次执行各个操作，执行完每个操作之后，递归执行以上过程。  
为了加速SearchSolver，在最后一层搜索的时候，直接判断是否存在一步置换就能还原的情况。  
# SearchSolver可以替代HalfSolver和GreedySolver
SearchSolver其实是可以替代HalfSolver和GreedySolver。 
SearchSolver搜索两层就是HalfSolver。  
SearchSolver搜索深度无限大，每一层的搜索宽度设置为1，就是GreedySolver。    