https://baike.baidu.com/item/%E4%B8%8A%E5%B8%9D%E4%B9%8B%E6%95%B0/10098625

二阶魔方在3种操作的情况下上帝之数是19，现在考虑它的一半操作。  
执行10步所能够形成的全部置换，把10步之内所能够得到的置换全部存储起来。  
当来一个问题的时候，等价于把这个问题对应的置换，分解为两个置换的乘积操作。  
空间复杂度较低，时间复杂度略高。  

这种方式能够避免状态数过多导致的状态爆炸问题。实际上，这种方法就是双向广度优先搜索的变形，但是实现比广度优先方法要灵活许多。     

同样，使用这种方法还可以实现把一个置换拆分成3份，这样空间复杂度会进一步降低。  


这种算法等价于：把比较少的基本操作需要很多步才能完成，转化为了比较多的基本操作需要很少的步完成。是一种用时间换空间的策略。    

获得了很多个操作之后，可以使用`A*`算法贪心搜索让尽量多的块实现复原。但是可能存在一些问题，使用`A*`计算量太大。    

搜索n层，然后将问题对应的置换分解为三个置换的乘积。如果直接硬搞，复杂度是`N*N`,N表示搜索n层之后的全部置换种数。为了降低复杂度，第一步使用启发式搜索，优先选择离目标尽量近的一种操作，然后通过O(N)复杂度判断是否可解。    

三阶魔方能够解决18步以内可以解决的东西。把三阶魔方的还原分成几个步骤：第一步，把底层还原；第二步，把中间层还原；第三步，把上层还原。只要每一步都可以在18步内解决，那么魔方就能够被还原。  
这种方法几乎是万能的，把一个大目标拆解为若干个小目标，然后确保每个小目标能够实现。  

三阶魔方最简操作方式，使用6层打表搜索2步的SearchSolver，解决随机旋转5步的问题，在很多时候是不成功的。因为随机旋转5步是正向旋转5步，如果正向旋转5步，那么要想使用正向操作还原它的时候，可能需要15步才能还原它。所以可以把搜索步数改为3步，或者把打表层数改为8层。     